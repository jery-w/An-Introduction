/**
 * pointer - reference and dereference
 *
 * int i;
 * int *pi = &i;	// or: int *pi;		pi = &i;
 * 
 * &是取地址运算符（Address Operator），&i表示取变量i的地址
 * *号是指针间接寻址运算符（Indirection Operator），*pi表示取指针pi
 * 所指向的变量的值
 * 指针有时称为变量的引用（Reference），所以根据指针找到变量称为Dereference
 *
 * 用一个指针给另一个指针赋值时要注意，两个指针必须是同一类型的。可以先进行强制
 * 类型转换后再进行赋值。
 */
pi = (int *)pc;
/**
 * 像这种指向不确定地址的指针称为“野指针”（UnboundPointer），为避免出现野指针，
 * 在定义指针变量时就应该给它明确的初值，或者把它初始化为NULL：
 * int *p = NULL;
 */

/**
 * pointer & array
 *
 */
int a[10];
int *pa = &a[0];
pa++;
/**
 * 注意后缀运算符的优先级高于单目运算符，所以是取a[0]的地址，而不是取 a的地址。
 * 数组名做右值时转换成指向首元素的指针，但做左值仍然表示整个数组的存储空间，
 * 而不是首元素的存储空间.
 * 在函数原型中，如果参数是数组，则等价于参数是指针的形式
 * void func(int a[10])		// or: void func(int a[])
 * {
 * 		...
 * }
 * 等价于
 * void func(int *a)
 * {
 *		...
 * }
 * 参数写成指针形式还是数组形式对编译器来说没区别，都表示这个参数是指针，之所以
 * 规定两种形式是为了给读代码的人提供有用的信息，如果这个参数指向一个元素，通常
 * 写成指针的形式，如果这个参数指向一串元素中的首元素，则经常写成数组的形式。
 */
 
/**
 * 指针与const限定符
 * a是一个指向const int型的指针，a所指向的内存单元不可改写
 * const int *a;
 * int const *a; 
 *
 * a是一个指向int型的const指针，*a是可以改写的，但a不允许改写。
 * int * const a;
 *
 * a是一个指向const int型的const指针，因此*a和a都不允许改写。
 * int const * const a;
 *
 * 良好的编程习惯应该尽可能多地使用const，因为：
 * 1. const给读代码的人传达非常有用的信息。比如一个函数的参数是const char*，
 * 你在调用这个函数时就可以放心地传给它char *或const char *指针，
 * 而不必担心指针所指的内存单元被改写。
 * 2. 尽可能多地使用const限定符，把不该变的都声明成只读，这样可以依靠编译器
 * 检查程序中的Bug，防止意外改写数据。
 * 3. const对编译器优化是一个有用的提示，编译器也许会把const变量优化成常量。
 */
 
/**
 * 指针与结构体
 * 要通过指针p访问结构体成员可以写成(*p).c和(*p).num，为了书写方便，C语言
 * 提供了->运算符，也可以写成p->c和p->num。
 */
struct unit {
	char c;
	int num;
};
struct unit u;
struct unit *p = &u;

/**
 * 指向指针的指针与指针数组 / 多级指针
 * 
 * 表达式*ppi取pi的值，表达式**ppi取i的值
 * int i;
 * int *pi = &i;
 * int **ppi = &pi;
 *
 * 指针数组。int *a[10];和int **pa;之间的关系类似于int a[10];和int *pa; 
 * 之间的关系：a是由一种元素组成的数组，pa则是指向这种元素的指针。所以，
 * 如果pa指向 a的首元素:
 * int *a[10];
 * int **pa = &a[0];
 *
 * main函数的标准原型应该是int main(int argc, char *argv[]);。 
 * argc是命令行参数的个数。而argv是一个指向指针的指针，为什么不是指针数组呢？
 * 因为前面讲过，函数原型中的[]表示指针而不表示数组，等价于char **argv。 
 * 那为什么要写成char *argv[]而不写成char **argv呢？这样写给读代码的人
 * 提供了有用信息，argv不是指向单个指针，而是指向一个指针数组的首元素。
 * 数组中每个元素都是char *指针，指向一个命令行参数字符串。
 */
 
/**
 * 指向数组的指针与多维数组
 * 
 * 以下定义一个指向数组的指针，该数组有10个int元素：
 * int (*a)[10];
 * 与int *a[10];相比，仅仅多了一个()括号。如何记住和区分这两种定义呢？
 * 我们可以认为[]比*有更高的优先级，如果a先和*结合则表示a是一个指针，如果
 * a先和[]结合则表示 a是一个数组。
 *
 * 指向数组的指针如何使用：
 * int a[10];
 * int (*p)[10] = &a;
 * a是一个数组，在&a这个表达式中，数组名做左值，取整个数组的首地址赋给指针pa。
 * 注意，&a[0]表示数组a的首元素的首地址，而&a表示数组a的首地址，显然这两个地址
 * 的数值相同，但这两个表达式的类型是两种不同的指针类型，前者的类型是int*，
 * 而后者的类型是int (*)[10]。
 *
 * int a[5][10];和int (*pa)[10];之间的关系同样类似于int a[10];和int *pa; 
 * 之间的关系：a是由一种元素组成的数组，pa则是指向这种元素的指针。所以，
 * 如果pa指向 a的首元素：
 * int a[5][10]; 
 * int (*pa)[10] = &a[0]; 
 * 则pa[0]和a[0]取的是同一个元素，唯一比原来复杂的地方在于这个元素是由10个int
 * 组成的数组，而不是基本类型。这样，我们可以把pa当成二维数组名来使用，
 * pa[1][2]和a[1][2]取的也是同一个元素，而且pa比a用起来更灵活，数组名不支持
 * 赋值、自增等运算，而指针可以支持，pa++使pa跳过二维数组的一行（40个字节），
 * 指向a[1]的首地址。
 */
 
/**
 * 函数类型和函数指针类型
 *
 * 在C语言中，函数也是一种类型，可以定义指向函数的指针。我们知道，指针变量的
 * 内存单元存放一个地址值，而函数指针存放的就是函数的入口地址（位于.text段）。
 */
#include <stdio.h>

void say_hello(const char *str)
{
	printf("hello s%\n, str);
}

int main(void)
{
	void (*f)(const char *str) = say_hello;
	f("GUYS");
	
	return 0;
}
/**
 * 分析一下变量f的类型声明void (*f)(const char *)，f首先跟*号结合在一起，
 * 因此是一个指针。(*f)外面是一个函数原型的格式，参数是const char *，返
 * 回值是void，所以f是指向这种函数的指针。而say_hello的参数是const char *，
 * 返回值是void，正好是这种函数，因此 f可以指向say_hello。注意，say_hello
 * 是一种函数类型，而函数类型和数组类型类似，做右值使用时自动转换成函数指
 * 针类型，所以可以直接赋给f，当然也可以写成void (*f)(const char *) = 
 * &say_hello;，把函数say_hello先取地址再赋给f，就不需要自动类型转换了。
 * 
 * 可以直接通过函数指针调用函数，如上面的f("Guys")，也可以先用*f取出它所
 * 指的函数类型，再调用函数，即(*f)("Guys")。可以这么理解：函数调用运算符
 * ()要求操作数是函数指针，所以f("Guys")是最直接的写法，而
 * say_hello("Guys")或(*f)("Guys")则是把函数类型自动转换成函数指针然后做
 * 函数调用。
 */
 
